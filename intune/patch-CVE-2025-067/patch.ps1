$TargetDllFullPath = '' #add the target libcurl dll file here 

$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition
$tempDir = Join-Path $scriptDir "TempCurlDownload" # Temporary download and extraction
$backupDir = "C:\Temp\backuplibcurl"              # Backup location for original DLLs

try {
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Write-Host "TLS 1.2 has been set for the current PowerShell session." -ForegroundColor Green
} catch {
    Write-Warning "Failed to set TLS 1.2. Downloads might fail if the OS/PowerShell version is old and the site requires modern TLS."
    Write-Warning "Error: $($_.Exception.Message)"
}
Write-Host "------------------------------------------------------------------------------------------"

Function Get-PEArchitecture {
    param(
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )
    $FileStream = $null
    $BinaryReader = $null

    try {
        $FileStream = New-Object System.IO.FileStream($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::Read)
        $BinaryReader = New-Object System.IO.BinaryReader($FileStream)

        if ($FileStream.Length -lt (0x3C + 4)) { # e_lfanew offset + size of e_lfanew
            return "File too small (DOS Header)"
        }
        $FileStream.Seek(0x3C, [System.IO.SeekOrigin]::Begin) | Out-Null
        $peHeaderOffset = $BinaryReader.ReadUInt32()

        if ($FileStream.Length -lt ($peHeaderOffset + 4 + 2)) { # PE Signature (4 bytes) + Machine field (2 bytes)
            return "File too small (PE Header/COFF)"
        }
        $FileStream.Seek($peHeaderOffset, [System.IO.SeekOrigin]::Begin) | Out-Null
        $peSignature = $BinaryReader.ReadUInt32()
        if ($peSignature -ne 0x00004550) { # "PE\0\0"
            return "Not a PE file (Invalid Signature)"
        }

        $machineType = $BinaryReader.ReadUInt16() # This is the IMAGE_FILE_HEADER.Machine field

        switch ($machineType) {
            0x014c  { return "x86 (32-bit)" }      # IMAGE_FILE_MACHINE_I386
            0x8664  { return "x64 (64-bit)" }      # IMAGE_FILE_MACHINE_AMD64
            0xaa64  { return "ARM64" }             # IMAGE_FILE_MACHINE_ARM64
            0x01c4  { return "ARM (Thumb-2 LE)" }  # IMAGE_FILE_MACHINE_ARMNT
            0x0200  { return "IA64 (Itanium)" }    # IMAGE_FILE_MACHINE_IA64
            0x0     { return "Unknown" }           # IMAGE_FILE_MACHINE_UNKNOWN
            default { return "Other ($('0x{0:X4}' -f $machineType))" }
        }
    } catch {
        Write-Warning "Error reading PE architecture for '$FilePath': $($_.Exception.Message)"
        return "Error Reading Architecture"
    } finally {
        if ($BinaryReader -ne $null) { $BinaryReader.Close() }
        elseif ($FileStream -ne $null) { $FileStream.Close() }
    }
}
# --- End of Get-PEArchitecture function ---

# --- Main Script Logic ---
Write-Host "Starting libcurl.dll update process for: $TargetDllFullPath" -ForegroundColor Yellow
Write-Host "------------------------------------------------------------------------------------------"

# 1. Validate Target DLL
Write-Host "Step 1: Validating Target DLL..." -ForegroundColor Cyan
if (-not (Test-Path $TargetDllFullPath -PathType Leaf)) {
    Write-Error "Target DLL not found: $TargetDllFullPath"
    exit 1
}
$TargetDllInfo = Get-Item $TargetDllFullPath
$OriginalTargetDllName = $TargetDllInfo.Name
$TargetDllDirectory = $TargetDllInfo.DirectoryName

Write-Host "Target DLL '$OriginalTargetDllName' found at '$TargetDllDirectory'."
Write-Host "------------------------------------------------------------------------------------------"

# 2. Determine Target Architecture
Write-Host "Step 2: Determining Target Architecture..." -ForegroundColor Cyan
$architecture = Get-PEArchitecture -FilePath $TargetDllFullPath
Write-Host "Detected architecture: $architecture"

$downloadUrl = $null
$zipFileName = $null
$internalZipFolderName = $null
$internalDllName = $null

switch ($architecture) {
    "x64 (64-bit)" {
        $zipFileName = "curl-8.13.0_3-win64-mingw.zip" # Using a recent version as an example, check curl.se for latest
        $internalZipFolderName = "curl-8.13.0_3-win64-mingw"
        $internalDllName = "libcurl-x64.dll"
    }
    "x86 (32-bit)" {
        $zipFileName = "curl-8.13.0_3-win32-mingw.zip"
        $internalZipFolderName = "curl-8.13.0_3-win32-mingw"
        $internalDllName = "libcurl.dll"
    }
    "ARM64" {
        $zipFileName = "curl-8.13.0_3-win64a-mingw.zip"
        $internalZipFolderName = "curl-8.13.0_3-win64a-mingw"
        $internalDllName = "libcurl-arm64.dll"
    }
    default {
        Write-Error "Unsupported or unknown architecture: $architecture. Cannot determine download link for official curl.se builds."
        exit 1
    }
}

$curlVersionForURL = "8.13.0_3" # Make sure this matches the filenames above
$downloadUrl = "https://curl.se/windows/dl-$($curlVersionForURL)/$zipFileName"

Write-Output "Download URL: $downloadUrl"
$downloadedZipPath = Join-Path $tempDir $zipFileName

$pathAfterZipFolder = Join-Path $tempDir $internalZipFolderName
$pathToBin = Join-Path $pathAfterZipFolder "bin"
$extractedDllSourcePath = Join-Path $pathToBin $internalDllName
Write-Host "------------------------------------------------------------------------------------------"

# 3. Download and Unzip
Write-Host "Step 3: Downloading and Unzipping Patched DLL..." -ForegroundColor Cyan
Write-Host "Preparing to download $zipFileName for $architecture architecture."

if (Test-Path $tempDir) {
    Write-Host "Removing existing temporary directory: $tempDir"
    Remove-Item $tempDir -Recurse -Force
}
New-Item -Path $tempDir -ItemType Directory -Force | Out-Null

Write-Host "Downloading from $downloadUrl ..."
try {
    Invoke-WebRequest -Uri $downloadUrl -OutFile $downloadedZipPath -UseBasicParsing -ErrorAction Stop
    Write-Host "Download complete: $downloadedZipPath"
    Unblock-File -Path $downloadedZipPath
} catch {
    $errorMessage = "Failed to download file '$zipFileName' from '$downloadUrl'."
    if ($_ -ne $null) {
        $errorMessage += "`nError Record: $($_.ToString())"
        if ($_.Exception -ne $null) {
            $errorMessage += "`nException Type: $($_.Exception.GetType().FullName)"
            $errorMessage += "`nException Message: $($_.Exception.Message)"
            if ($_.Exception.InnerException -ne $null) {
                $errorMessage += "`nInner Exception Type: $($_.Exception.InnerException.GetType().FullName)"
                $errorMessage += "`nInner Exception Message: $($_.Exception.InnerException.Message)"
            }
        }
        if ($_.Exception -is [System.Net.WebException]) {
            $webEx = $_.Exception
            $errorMessage += "`nWebException Status: $($webEx.Status)"
            if ($webEx.Response -ne $null) {
                try {
                    $httpResponse = $webEx.Response -as [System.Net.HttpWebResponse]
                    if ($httpResponse -ne $null) {
                        $errorMessage += "`nHTTP Status Code: $([int]$httpResponse.StatusCode) ($($httpResponse.StatusCode))"
                        $errorMessage += "`nHTTP Status Description: $($httpResponse.StatusDescription)"
                    }
                } finally {
                    if ($webEx.Response -ne $null) { $webEx.Response.Close() }
                }
            }
        }
        $errorMessage += "`nScriptStackTrace: $($_.ScriptStackTrace)"
    } else {
        $errorMessage += "`nNo further error details available in `$_."
    }
    Write-Error $errorMessage

    if (Test-Path $tempDir) {
        Write-Host "Cleaning up failed download temp directory: $tempDir"
        Remove-Item $tempDir -Recurse -Force
    }
    exit 1
}

Write-Host "Extracting $downloadedZipPath to $tempDir ..."
try {
    Expand-Archive -Path $downloadedZipPath -DestinationPath $tempDir -Force
    Write-Host "Extraction complete."
} catch {
    Write-Error "Failed to extract archive '$zipFileName': $($_.Exception.Message)"
    if (Test-Path $tempDir) {
        Write-Host "Cleaning up failed extraction temp directory: $tempDir"
        Remove-Item $tempDir -Recurse -Force
    }
    exit 1
}

if (-not (Test-Path $extractedDllSourcePath -PathType Leaf)) {
    Write-Error "Patched DLL not found at expected path after extraction: $extractedDllSourcePath"
    Write-Error "Please check the internal structure of the zip file $zipFileName if it has changed on curl.se, or if the extraction failed silently."
    if (Test-Path $tempDir) {
        Write-Host "Cleaning up incomplete extraction temp directory: $tempDir"
        Remove-Item $tempDir -Recurse -Force
    }
    exit 1
}
Write-Host "Patched DLL found at: $extractedDllSourcePath"
Write-Host "------------------------------------------------------------------------------------------"

Write-Host "Step 4: Stopping Processes Using Target DLL..." -ForegroundColor Cyan
Write-Host "Attempting to find and stop processes using '$OriginalTargetDllName' at '$TargetDllFullPath'..."
$processesUsingDll = @()
try {
    $openfiles = Get-Process -ErrorAction SilentlyContinue | ForEach-Object {
        $process = $_
        try {
            $process.Modules | Where-Object {$_.FileName -eq $TargetDllFullPath} | ForEach-Object {
                [PSCustomObject]@{
                    ProcessName = $process.ProcessName
                    Id          = $process.Id
                    Path        = $process.Path 
                }
            }
        } catch {
        }
    } | Select-Object -Unique

    if ($openfiles.Count -gt 0) {
        $processesUsingDll = $openfiles
    }
} catch {
    Write-Warning "An error occurred while trying to determine processes using the DLL: $($_.Exception.Message). Manual check might be needed."
}

if ($processesUsingDll.Count -gt 0) {
    Write-Warning "The following processes appear to be using '$OriginalTargetDllName' and will be stopped:"
    $processesUsingDll | ForEach-Object { Write-Warning "- $($_.ProcessName) (PID: $($_.Id)) Path: $($_.Path)" }

    foreach ($processInfo in $processesUsingDll) {
        Write-Host "Stopping process: $($processInfo.ProcessName) (PID: $($processInfo.Id))"
        Stop-Process -Id $processInfo.Id -Force -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2 
        if (Get-Process -Id $processInfo.Id -ErrorAction SilentlyContinue) {
            Write-Warning "Failed to stop process $($processInfo.ProcessName) (PID: $($processInfo.Id)). Replacement may fail."
        } else {
            Write-Host "Process $($processInfo.ProcessName) stopped."
        }
    }
} else {
    Write-Host "No running processes found actively using '$OriginalTargetDllName' at the specified path (or enumeration failed/access denied)."
}
Write-Host "------------------------------------------------------------------------------------------"

Write-Host "Step 5: Replacing Target DLL..." -ForegroundColor Cyan
Write-Host "Backing up original DLL to $backupDir..."

if (-not (Test-Path $backupDir)) {
    New-Item -Path $backupDir -ItemType Directory -Force | Out-Null
    Write-Host "Backup directory created: $backupDir"
}

$backupFile = Join-Path $backupDir "$($OriginalTargetDllName).bak"

Write-Host "Backing up $TargetDllFullPath to $backupFile (will overwrite if exists)..."
Copy-Item -Path $TargetDllFullPath -Destination $backupFile -Force
Write-Host "Backed up original '$OriginalTargetDllName' to '$backupFile'"

Write-Host "Attempting to remove original DLL: $TargetDllFullPath"
Remove-Item -Path $TargetDllFullPath -Force -ErrorAction SilentlyContinue
Start-Sleep -Seconds 1
if(Test-Path $TargetDllFullPath){
    Write-Warning "Failed to remove $TargetDllFullPath. It might still be locked. Will attempt overwrite during copy."
} else {
    Write-Host "Original DLL removed."
}

$tempDestinationPathWithOriginalName = Join-Path $TargetDllDirectory $internalDllName
Write-Host "Copying patched DLL '$extractedDllSourcePath' to '$tempDestinationPathWithOriginalName'."
Copy-Item -Path $extractedDllSourcePath -Destination $tempDestinationPathWithOriginalName -Force
Unblock-File -Path $tempDestinationPathWithOriginalName
Write-Host "Copied patched DLL."

if ($internalDllName -ne $OriginalTargetDllName) {
    $finalDestinationPath = Join-Path $TargetDllDirectory $OriginalTargetDllName
    Write-Host "Renaming '$tempDestinationPathWithOriginalName' to '$finalDestinationPath'."
    if ((Test-Path $finalDestinationPath) -and ($tempDestinationPathWithOriginalName -ne $finalDestinationPath)) {
        Write-Host "Removing existing file at final destination before rename: $finalDestinationPath"
        Remove-Item $finalDestinationPath -Force -ErrorAction SilentlyContinue # Ensure target name is free
    }
    Rename-Item -Path $tempDestinationPathWithOriginalName -NewName $OriginalTargetDllName -Force
    Write-Host "Patched DLL renamed and in place: $finalDestinationPath"
} else {
    $finalDestinationPath = $tempDestinationPathWithOriginalName
    Write-Host "Patched DLL copied and in place (name was already correct): $finalDestinationPath"
}

if (-not (Test-Path $finalDestinationPath)) {
     Write-Error "Replacement failed. Final target DLL '$OriginalTargetDllName' not found at '$TargetDllDirectory'."
} else {
    Write-Host "Successfully verified patched DLL '$OriginalTargetDllName' at '$TargetDllDirectory'." -ForegroundColor Green
}
Write-Host "------------------------------------------------------------------------------------------"

# 6. Cleanup
Write-Host "Step 6: Cleaning Up Temporary Files..." -ForegroundColor Cyan
Start-Sleep -Seconds 2 
if (Test-Path $tempDir) {
    Write-Host "Removing temporary directory: $tempDir"
    try {
        Remove-Item $tempDir -Recurse -Force -ErrorAction Stop 
        Write-Host "Temporary directory removed successfully."
    } catch {
        Write-Warning "Failed to completely remove temporary directory '$tempDir'. Error: $($_.Exception.Message)"
        Write-Warning "Manual cleanup of this directory might be required."
    }
} else {
    Write-Host "Temporary directory '$tempDir' not found or already removed."
}
Write-Host "------------------------------------------------------------------------------------------"

Write-Host "Libcurl.dll update process completed for: $TargetDllFullPath" -ForegroundColor Green
Write-Warning "It is recommended to test the application that uses this DLL thoroughly."
Write-Warning "If issues occur, restore the DLL from the backup: $backupFile"